<!DOCTYPE html>
<!-- Copyright (c) 2019 Jarret Dyrbye
Distributed under the MIT software license, see the accompanying
file LICENSE or http://www.opensource.org/licenses/mit-license.php -->
<html>
<head>
<title>BannerPunk!</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="description" content="A demonstaration of Lightning Network-driven banner art space sold by invoiceless micropayments.">
<meta name="keywords" content="crypto,art,image,bitcoin,lightning-network,micropayment">
<link rel="canonical" href="https://bannerpunk.biz"/>

<!-- Favicon Data -->
<link rel="icon"
      type="image/png"
      href="/img/icon.png">

<!-- Structured Data -->
<script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "Organization",
        "name": "bannerpunk.biz",
        "url": "https://bannerpunk.biz",
        "logo": "https://bannerpunk.biz/img/logo.png",
        "sameAs": "http://www.twitter.com/sparkshot_io"
    }
</script>

<!-- Open Graph -->
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:site" content="@sparkshot_io" />
<meta name="twitter:title" content="BannerPunk!" />
<meta name="twitter:description" content="Banner image art space sold with invoiceless micropayments!" />
<meta name="twitter:image" content="https://bannerpunk.biz/img/logo.png" />

<meta property="og:title" content="BannerPunk!" />
<meta property="og:type" content="website" />
<meta property="og:site_name" content="BannerPunk!" />
<meta property="og:url" content="https://bannerpunk.biz" />
<meta property="og:image" content="https://bannerpunk.biz/img/logo.png" />
<meta property="og:image:width" content="430" />
<meta property="og:image:height" content="195" />
<meta property="og:image:type" content="image/png" />
<meta property="og:image:alt" content="BannerPunk!" />
<meta property="og:description" content="Banner image art space sold with invoiceless micropayments!" />

<!-- CSS -->
<style>
    P.body {
        margin-left: auto;
        margin-right: auto;
        max-width: 43em;
        min-width: 15em;
        margin-top: 20px;
        margin-bottom: 20px;
    }
    .row {
        max-width: 65em;
    }
    .row:after {
      content: "";
      display: table;
      clear: both;
    }
    .column-text {
      float: left;
      width: 70%;
    }
    .column-logo {
      float: left;
      width: 70%;
    }
    .column-logo-side {
      float: right;
      width: 30%;
    }
    .column-grid {
      float: left;
      width: 30%;
    }
    li{
      margin: 10px 0;
    }
</style>
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css" integrity="sha384-5sAR7xN1Nv6T6+dT2mhtzEpVJvfS3NScPQTrOxhwjIuvcA67KV2R5Jz6kr4abQsz" crossorigin="anonymous">
</head>

<body>
    <center>
    <br>
    <a href="https://bannerpunk.biz"><img src="img/logo.png" alt="BannerPunk!"></a>
    <P class='body'>
    <br>...was built for the <a href="https://boltathon.com/">Bolt-A-Thon 2</a> hackathon on December 6th, 7th and 8th, 2019. Watch the <a href=" https://youtu.be/9xub9jgajkI">hackathon submission video</a>.
    </P>
    <br>

    <!-- banner space 0 -->
    <div id="grid-0"></div>
    <div class= "row">
        <div class="column-text">
        <P class='body'>
        The rectangle area above this text <i class="fas fa-arrow-up"></i> and beside this text <i class="fas fa-arrow-right"></i> are pixel grids where you may draw pixels via sending special messages in-band via the Lightning Network. The images will update with the drawings in <b>real-time</b> on this page via websocket.
        </P>
        <P class='body'>
        These drawing spaces can be placed like banner ads on your website, such that you can earn satoshis from people that want to set content for your web visitors to see. BannerPunk is open source software and a server can be run with your own Lightning Network node for your own website. <br><a href="https://github.com/jarret/bannerpunk" style="text-decorations:none; color:inherit;" target="_blank"><i class="fab fa-github-square fa-3x"></i></a>
</a>
        </P>
        <P class='body'>
        Here is another banner image space, but of the type you typically see that is inline in an article's text body <br><i class="fas fa-arrow-down"></i>
        </P>

        <!-- banner space 2 -->
        <div id="grid-2"></div>
        <br>

        <h3> How to Draw </h3>

        <P class='body'>
        The banner images on this page can be drawn to by paying <a href="https://1ml.com/node/02e389d861acd9d6f5700c99c6c33dd4460d6f1e2f6ba89d1f4f36be85fc60f8d7" target="_blank">our node</a> (inbound channels appreciated). However it needs to be done in a special way, but don't worry, we wrote scripts for <a href="https://github.com/jarret/bannerpunk/blob/master/c-lightning-draw.py" target="_blank">C-Lightning</a> and <a href="https://github.com/jarret/bannerpunk/blob/master/lnd-draw.py" target="_blank">LND</a> to make it easy. More documentation is in the <a href="https://github.com/jarret/bannerpunk/blob/master/README.md" target="_blank">README.md</a>, The content of .pngs can be drawn (at a cost of 1 satoshi per pixel, plus any routing fees) like so:
        </P>
        <code class="body">
        $ ./lnd-draw.py png /path/to/lncli image_no x_offset y_offset /path/to/source/image.png
        </code>
        <br>
        <br>

        <code class="body">
        $ ./c-lightning-draw.py png /path/to/lightning-rpc image_no x_offset y_offset /path/to/source/image.png
        </code>


        <P class='body'>
        The top banner ad space is <b>256</b> pixels wide and <b>60</b> pixels tall with a 3x3 dot size. When writing it is addressable as image number <b>0</b>
        </P>
        <P class='body'>
        The side banner ad space is <b>60</b> pixels wide and <b>256</b> pixels tall with a 3x3 dot size. When writing it is addressable as image number <b>1</b>
        </P>
        <P class='body'>
        The inline article space is <b>256</b> pixels wide and <b>256</b> pixels tall with a 1x1 dot size. When writing it is addressable as image number <b>2</b>
        </P>

        <P class='body'>
        These scripts have software dependencies, so please read <a href="https://github.com/jarret/bannerpunk/blob/master/README.md" target="_blank">the documentation</a>.
        </P>

        <h3> How Drawing Works </h3>

        <P class='body'>
        To draw without the use of the scripts, three things must be done:
        <ol>
        <li>The image number, pixel coordinates and RGB color values must be encoded into preimages. Only 4 pixels fit per preimage, so larger drawings must do multiple payments.</li>
        <li>A payment using the encoded preimage mus be Forwarded through the bannerpunk-hosting node.</li>
        <li>The forwarding payment must pay a forwarding fee to that node that is at least 1 satoshi per encoded pixel</li>
        </ol>

        <h4> Preimage Pixel Encoding </h4>

        <a href="img/pixel_format.png" target="_blank"><img src="img/pixel_format.png" alt="Pixel Format" width="600"></a>
        <P class='body'>
        Up to four pixels can be encoded in a 256-bit payment preimage. <a href="https://github.com/jarret/bannerpunk/blob/master/bannerpunk/pixel_preimage.py" target="_blank">pixel_preimage.py</a> provides classes to help with encoding and decoding these values.
        </P>

        <h4> Forwarding A Payment </h4>
        <P class='body'>
        Typically, you might think of Lightning Network payment forwarding as looking like this:
        </P>
        <a href="img/forward.png" target="_blank"><img src="img/forward.png" alt="Pixel Format" width="600"></a>
        <P class='body'>
        This will work for BannerPunk, however this is <b>not</b> how our example scripts (<a href="https://github.com/jarret/bannerpunk/blob/master/c-lightning-draw.py" target="_blank">C-Lightning</a> and <a href="https://github.com/jarret/bannerpunk/blob/master/lnd-draw.py" target="_blank">LND</a>) operate. This scenario is <b>not ideal</b> because it requires coordination between Alice and Carol to set up and trigger.
        </P>
        <P class='body'>
        Instead, the easiest way to draw is via setting up a circular payment where Alice pays her own invoice via a route she choses to include the target BannerPunk node.
        </P>
        <a href="img/circular.png" target="_blank"><img src="img/circular.png" alt="Pixel Format" width="600"></a>
        <P class='body'>
        This enables Alice to set all the parameters and trigger the payment herself without needing to coordinate.
        </P>

        <h3> Future Improvements </h3>

        <P class='body'>
        Using/abusing the preimage this way to carry a message payload has disadvantages. Using the upcoming <a href="https://github.com/lightningnetwork/lightning-rfc/blob/master/04-onion-routing.md"target="_blank">TLV message payload</a> functionality would be an improvement, however that is not in widespread support yet.
        </P>
        <P class='body'>
        The pixel-encoding preimage is also visible by all parties involved in the route. It would be better if it was encrypted as a shared secret between the payer and the BannerPunk target node. Perhaps using <a href="https://crypto.stackexchange.com/questions/45040/can-elliptic-curve-cryptography-encrypt-with-public-key-and-decrypt-with-private" target="_blank">a scheme like this</a>
        </P>

        <h3> Thanks! </h3>

        </div>

        <div class="column-grid">
        <!-- banner space 1 -->
        <div id="grid-1"></div>
        </div>
    </div>

    </center>
</body>

<script src="js/import/pako.js"></script>
<script type="text/javascript">

var AppSocket;

const WEBSOCKET = "wss://ws.bannerpunk.biz:443";

const WIDTH_0 = 256;
const HEIGHT_0 = 60;
const PX_SIZE_0 = 3;

const WIDTH_1 = 60;
const HEIGHT_1 = 256;
const PX_SIZE_1 = 3;

const WIDTH_2 = 256;
const HEIGHT_2 = 256;
const PX_SIZE_2 = 1;


const PIXEL_RECORD_SIZE = 3;

function drawColor(ctx, px_size, x, y, color) {
    ctx.fillStyle = color;

    lx = (px_size * x);
    //ly = (PX_SIZE * HEIGHT) - (PX_SIZE * (y + 1));
    ly = (px_size * y);

    ctx.fillRect(lx, ly, px_size, px_size);
}

function getCanvasContext(image_no) {
    if (image_no == 0) {
        c = document.getElementById("canvas-0");
        return c.getContext("2d");
    } else if (image_no == 1) {
        c = document.getElementById("canvas-1");
        return c.getContext("2d");
    } else {
        c = document.getElementById("canvas-2");
        return c.getContext("2d");
    }
}

function CreateCanvas0() {
    t = document.getElementById("grid-0");
    c = document.createElement("canvas");
    c.setAttribute("id", "canvas-0")
    c.setAttribute("width", WIDTH_0 * PX_SIZE_0);
    c.setAttribute("height", HEIGHT_0 * PX_SIZE_0);
    c.setAttribute("style", "border:1px solid #000000;");
    t.appendChild(c);
    return c;
}

function CreateCanvas1() {
    t = document.getElementById("grid-1");
    c = document.createElement("canvas");
    c.setAttribute("id", "canvas-1");
    c.setAttribute("width", WIDTH_1 * PX_SIZE_1);
    c.setAttribute("height", HEIGHT_1 * PX_SIZE_1);
    c.setAttribute("style", "border:1px solid #000000;");
    t.appendChild(c);
    return c;
}

function CreateCanvas2() {
    t = document.getElementById("grid-2");
    c = document.createElement("canvas");
    c.setAttribute("id", "canvas-2");
    c.setAttribute("width", WIDTH_2 * PX_SIZE_2);
    c.setAttribute("height", HEIGHT_2 * PX_SIZE_2);
    c.setAttribute("style", "border:1px solid #000000;");
    t.appendChild(c);
    return c;
}

function CreateDisplay() {
    var canvas0 = CreateCanvas0();
    var draw0 = canvas0.getContext("2d");
    var canvas1 = CreateCanvas1();
    var draw1 = canvas1.getContext("2d");
    var canvas2 = CreateCanvas2();
    var draw2 = canvas2.getContext("2d");

    for (var x = 0; x < WIDTH_0; x++) {
        for (var y = 0; y < HEIGHT_0; y++) {
            if (((x + y) % 2) == 1) {
                drawColor(draw0, PX_SIZE_0, x, y, "#ffffff");
            } else {
                drawColor(draw0, PX_SIZE_0, x, y, "#000000");
            }
        }
    }
    for (var x = 0; x < WIDTH_1; x++) {
        for (var y = 0; y < HEIGHT_1; y++) {
            if (((x + y) % 2) == 1) {
                drawColor(draw1, PX_SIZE_1, x, y, "#ffffff");
            } else {
                drawColor(draw1, PX_SIZE_1, x, y, "#000000");
            }
        }
    }
    for (var x = 0; x < WIDTH_2; x++) {
        for (var y = 0; y < HEIGHT_2; y++) {
            if (((x + y) % 2) == 1) {
                drawColor(draw2, PX_SIZE_2, x, y, "#ffffff");
            } else {
                drawColor(draw2, PX_SIZE_2, x, y, "#000000");
            }
        }
    }
}

function drawPixelUpdate(ctx, image_no, pixel) {
    //console.log("x: " + pixel.x);
    //console.log("y: " + pixel.y);
    //console.log("rgb: " + pixel.rgb);
    if (image_no == 0) {
        drawColor(ctx, PX_SIZE_0, pixel.x, pixel.y, "#" + pixel.rgb);
    } else if (image_no == 1) {
        drawColor(ctx, PX_SIZE_1, pixel.x, pixel.y, "#" + pixel.rgb);
    } else {
        drawColor(ctx, PX_SIZE_2, pixel.x, pixel.y, "#" + pixel.rgb);
    }
}

function drawPixelUpdates(image_no, pixels) {
    //console.log("image no: " + image_no);
    //console.log("pixels: " + pixels);

    ctx = getCanvasContext(image_no);

    for (var i = 0; i < pixels.length; i++) {
        var pixel = pixels[i];
        drawPixelUpdate(ctx, image_no, pixel);
    }
}


//////////////////////////////////////////////////////////////////////////////

CreateDisplay();

//////////////////////////////////////////////////////////////////////////////

function processReceivedNotification(event) {
    if (event.data instanceof Blob) {
        console.log(`processReceivedNotification: RECIEVED BINARY BLOB`);
        processReceivedBinaryNotification(event);
    } else {
         console.log(`processReceivedNotification: RECIEVED TEXT`);
        processReceivedTextNotification(event);
    }
}

function processReceivedTextNotification( event ) {
    const data = JSON.parse( event.data );
    const image_no = data.image_no;
    const pixels = data.pixels;
    drawPixelUpdates(image_no, pixels);
}

function processReceivedBinaryNotification(event) {
    // console.log(`processReceivedBinaryNotification`);
    printBinary(event.data);
    handleBinary(event.data);
}

function printBinary(data) {
    const reader = new FileReader();
    reader.readAsText(data);
    const txt = reader.result;
    console.log(txt);
}

function handleBinary(data) {
    // console.log(`handleBinary`);
    const reader = new FileReader();

    reader.onload = event => {
           console.log("starting decompression of " + event.target.result.byteLength + " bytes.");
           const compressed = new Uint8Array(event.target.result);
           const inflated = pako.inflate(compressed);
           handleNotification(inflated.buffer);
    };
    reader.readAsArrayBuffer(data);
}


function toHexColor(r, g, b) {
    var s = '#';
    s += ('0' + (r & 0xFF).toString(16)).slice(-2);
    s += ('0' + (g & 0xFF).toString(16)).slice(-2);
    s += ('0' + (b & 0xFF).toString(16)).slice(-2);
    return s;
}



function handleNotification(ab) {
    const ctx0 = getCanvasContext(0);
    const ctx1 = getCanvasContext(1);
    const ctx2 = getCanvasContext(2);
    console.log("starting binary parse of " + ab.byteLength + " bytes.");
    const dv = new DataView(ab);
    const len0 = HEIGHT_0 * WIDTH_0 * PIXEL_RECORD_SIZE
    const len1 = HEIGHT_1 * WIDTH_1 * PIXEL_RECORD_SIZE
    for (let x = 0; x < WIDTH_0; x++) {
        for (let y = 0; y < HEIGHT_0; y++) {
            let byte_offset = (x * PIXEL_RECORD_SIZE * HEIGHT_0) + (y * PIXEL_RECORD_SIZE);
            const r = dv.getUint8(byte_offset);
            const g = dv.getUint8(byte_offset + 1);
            const b = dv.getUint8(byte_offset + 2);
            let color = toHexColor(r, g, b);
            //console.log("parsed: " + color);
            drawColor(ctx0, PX_SIZE_0, x, y, color);
        }
    }
    for (let x = 0; x < WIDTH_1; x++) {
        for (let y = 0; y < HEIGHT_1; y++) {
            let byte_offset = len0 + (x * PIXEL_RECORD_SIZE * HEIGHT_1) + (y * PIXEL_RECORD_SIZE);
            const r = dv.getUint8(byte_offset);
            const g = dv.getUint8(byte_offset + 1);
            const b = dv.getUint8(byte_offset + 2);
            let color = toHexColor(r, g, b);
            //console.log("parsed: " + color);
            drawColor(ctx1, PX_SIZE_1, x, y, color);
        }
    }
    for (let x = 0; x < WIDTH_2; x++) {
        for (let y = 0; y < HEIGHT_2; y++) {
            let byte_offset = len0 + len1 + (x * PIXEL_RECORD_SIZE * HEIGHT_2) + (y * PIXEL_RECORD_SIZE);
            const r = dv.getUint8(byte_offset);
            const g = dv.getUint8(byte_offset + 1);
            const b = dv.getUint8(byte_offset + 2);
            let color = toHexColor(r, g, b);
            //console.log("parsed: " + color);
            drawColor(ctx2, PX_SIZE_2, x, y, color);
        }
    }
}


function ConnectUponLoad() {
    console.log("connecting");
    // create websocket instance
    AppSocket = new WebSocket(WEBSOCKET);
    // add event listener reacting when message is received
    AppSocket.onmessage = processReceivedNotification
    console.log("connected");
}

window.addEventListener("load", ConnectUponLoad());

//////////////////////////////////////////////////////////////////////////////


</script>
</html>
